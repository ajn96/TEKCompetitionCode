#pragma config(Sensor, in1,    mobileGoalAngle, sensorPotentiometer)
#pragma config(Sensor, in2,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  tankDriveSignal, sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, hasMobileGoal,  sensorTouch)
#pragma config(Motor,  port1,           armRight,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           goalRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           coneMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftInteriorMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftExteriorMotors, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightExteriorMotors, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightInteriorMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           goalLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armLeft,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  AutonomousCodePlaceholderForTesting();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

#define DEADZONE 30
#define ARM_SPEED 100
#define ROLLER_SPEED 60
#define GOAL_SPEED 100

void drive( bool isTank );
void moveArm( bool up, bool down );
void rollRoller( bool up, bool down );
void moveGoal( bool up, bool down );
task autoPickupGoal();
task autoDropMobile();
task autoHoldHeight();

int GOAL_START_ANGLE;
int ARM_CURRENT_ANGLE;
bool autoIsRunning;
bool autoLiftRunning;
bool autoHoldHeightRunning;

//edit

task usercontrol()
{
	const int LIFT_UP_BTN = Btn6U,
					  LIFT_DOWN_BTN = Btn6D,
					  CONE_UP_BTN = Btn8L,
					  CONE_DOWN_BTN = Btn8D,
					  GOAL_UP_BTN = Btn8U,
					  GOAL_DOWN_BTN = Btn8R,
					  AUTO_LIFT_MOBILE = Btn5U,
					  AUTO_LIFT_FIXED = Btn5D,
					  AUTO_HOLD_HEIGHT = Btn7D;

	GOAL_START_ANGLE = SensorValue[mobileGoalAngle];
	ARM_CURRENT_ANGLE = SensorValue[armAngle];

	bool isTank = true;
	autoIsRunning = false;
	autoLiftRunning = false;
	autoHoldHeightRunning = false;

	const int GOAL_OUT_ANGLE = 1030 / 360 * 15;
	const int ARM_DROP_ANGLE_FIXED = 2220;
	const int ARM_START_ANGLE = 50;

  while ( true ) {
  	drive( isTank ); // ( isTank )
  	if(!autoLiftRunning && !autoHoldHeightRunning)
  	{
  		moveArm( vexRT[LIFT_UP_BTN] == 1, vexRT[LIFT_DOWN_BTN] == 1); // ( up, down )
  	}
  	rollRoller( vexRT[CONE_UP_BTN] == 1, vexRT[CONE_DOWN_BTN] == 1 ); // ( up, down )
  	moveGoal( vexRT[GOAL_UP_BTN] == 1, vexRT[GOAL_DOWN_BTN] == 1 ); // ( up, down )
  	// Auto Goal Pickup Activation
  	int goalAngle = abs( SensorValue[mobileGoalAngle] - GOAL_START_ANGLE );
  	if ( goalAngle > GOAL_OUT_ANGLE &&
  		SensorValue[hasMobileGoal] == 1 && motor[goalLeft] == 0 ) {
  		startTask( autoPickupGoal );
  	}
  	if( vexRT[AUTO_LIFT_MOBILE])
  	{
  		startTask( autoDropMobile );
  	}
  	if( vexRT[AUTO_HOLD_HEIGHT] )
  	{
  		startTask ( autoHoldHeight);
  	}
  }
}

task autoPickupGoal() {
  autoIsRunning = true;
	int distance = abs( SensorValue[mobileGoalAngle] - GOAL_START_ANGLE );
	while ( distance > 10 ) {
		motor[goalRight] = motor[goalLeft] = -GOAL_SPEED;
		distance = abs( SensorValue[mobileGoalAngle] - GOAL_START_ANGLE );
	}
	motor[goalRight] = motor[goalLeft] = 0;
	autoIsRunning = false;
}

//raises arm to mobile goal drop point and drops cone
task autoDropMobile(){
	int motorSpeed;
	bool isDropped = false;
	autoLiftRunning = true;
	const int ARM_DROP_ANGLE_MOBILE = 1700;
	//raise at full speed to 1200
	while(SensorValue[armAngle] < 1200)
	{
		motor[armLeft] = motor[armRight] = 127;
	}

	while(SensorValue[armAngle] < ARM_DROP_ANGLE_MOBILE)
	{
		float speedMultiplier = (SensorValue[armAngle] - 1200)/ (ARM_DROP_ANGLE_MOBILE - 1200);
		speedMultiplier = speedMultiplier * 127;
		motorSpeed = 127 - (int) speedMultiplier;
		motor[armLeft] = motor[armRight] = motorSpeed;
	}
	motor[armLeft] = motor[armRight] = 0;
	clearTimer(T1);
	while(!isDropped)
	{
		if( SensorValue[armAngle] > ARM_DROP_ANGLE_MOBILE + 50 )
		{
			motor[armLeft] = motor[armRight] = -30;
		}
		else if ( SensorValue[armAngle] < ARM_DROP_ANGLE_MOBILE -50)
		{
			motor[armLeft] = motor[armRight] = 30;
		}
		else
		{
			motor[armLeft] = motor[armRight] = 0;
		}
		if (time1[T1] > 1000)
		{
			motor[coneMotor] = -ROLLER_SPEED;
		}
		if(time1[T1] > 2000)
		{
			motor[coneMotor] = 0;
			isDropped = true;
		}
	}
	autoLiftRunning = false;
}

task autoHoldHeight()
{
	const int holdAngle = 900;
	const int LIFT_UP_BTN = Btn6U,
	LIFT_DOWN_BTN = Btn6D;
	autoHoldHeightRunning = true;
	while(autoHoldHeightRunning)
	{
		if( SensorValue[armAngle] > holdAngle + 50 )
		{
				motor[armLeft] = motor[armRight] = -30;
		}
		else if ( SensorValue[armAngle] < holdAngle -50)
		{
				motor[armLeft] = motor[armRight] = 30;
		}
		else
		{
				motor[armLeft] = motor[armRight] = 0;
		}
		if(vexRT(LIFT_DOWN_BTN) || vexRT(LIFT_UP_BTN))
		{
			autoHoldHeightRunning = false;
		}
	}
}

void drive( bool isTank ) {
	if ( isTank ) {
		int leftSpeed = vexRT[Ch3];
		int rightSpeed = vexRT[Ch2];
		if ( abs( leftSpeed ) <= DEADZONE )	{
			leftSpeed = 0;
		}
		if ( abs( rightSpeed ) <= DEADZONE ) {
			rightSpeed = 0;
		}
		motor[rightInteriorMotor] = rightSpeed;
		motor[leftExteriorMotors] = leftSpeed;
		motor[rightExteriorMotors] = rightSpeed;
		motor[leftInteriorMotor] = leftSpeed;
	} else {
			motor[leftExteriorMotors] = motor[rightInteriorMotor]  = (vexRT[Ch3] - vexRT[Ch4]) / 2;  // (y + x)/2
    	motor[rightExteriorMotors] = motor[leftInteriorMotor] = (vexRT[Ch3] + vexRT[Ch4]) / 2;  // (y - x)/2
  }
}

void moveArm( bool up, bool down ) {
	if ( up ) {
		motor[armRight] = motor[armLeft] = ARM_SPEED;
	} else if ( down ) {
		motor[armRight] = motor[armLeft] = -ARM_SPEED;
	} else {
		motor[armRight] = motor[armLeft] = 0;
	}
}

void rollRoller( bool up, bool down ) {
	if ( up ) {
		motor[coneMotor] = ROLLER_SPEED;
	} else if ( down ) {
		motor[coneMotor] = -ROLLER_SPEED;
	} else {
		motor[coneMotor] = 0;
	}
}

void moveGoal( bool up, bool down ) {
	if ( up ) {
		motor[goalRight] = motor[goalLeft] = GOAL_SPEED;
	} else if ( down ) {
		motor[goalRight] = motor[goalLeft] = -GOAL_SPEED;
	} else if ( !autoIsRunning ) {
		motor[goalRight] = motor[goalLeft] = 0;
	}
}
